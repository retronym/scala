/* NSC -- new Scala compiler
 * Copyright 2005-2013 LAMP/EPFL
 * @author  Paul Phillips
 */

package scala.tools.nsc
package backend.jvm

import java.io.{ DataOutputStream, FileOutputStream, OutputStream, File => JFile }
import scala.tools.nsc.io._
import scala.tools.nsc.util.ScalaClassLoader
import scala.tools.util.{ Javap, JavapClass }
import java.util.jar.Attributes.Name
import scala.language.postfixOps
import scala.collection.{ mutable, immutable }
import scala.tools.asm
import asm.util.CheckClassAdapter
import scala.tools.asm.tree.analysis.AnalyzerException

/** For the last mile: turning generated bytecode in memory into
 *  something you can use.  Has implementations for writing to class
 *  files, jars, and disassembled/javap output.
 */
trait BytecodeWriters {
  val global: Global
  import global._

  private def outputDirectory(sym: Symbol): AbstractFile = (
    settings.outputDirs.outputDirFor(enteringFlatten(sym.sourceFile))
  )
  private def getFile(base: AbstractFile, /*cls.getName()*/ clsName: String, suffix: String): AbstractFile = {
    var dir = base
    val pathParts = clsName.split("[./]").toList
    for (part <- pathParts.init) {
      dir = dir.subdirectoryNamed(part)
    }
    dir.fileNamed(pathParts.last + suffix)
  }
  private def getFile(sym: Symbol, clsName: String, suffix: String): AbstractFile =
    getFile(outputDirectory(sym), clsName, suffix)

  trait BytecodeWriter {
    def writeClass(label: String, jclassName: String, jclassBytes: Array[Byte], sym: Symbol): Unit
    def close(): Unit = ()
    def verify(): Unit = ()
  }

  class DirectToJarfileWriter(jfile: JFile) extends BytecodeWriter {
    val jarMainAttrs = (
      if (settings.mainClass.isDefault) Nil
      else List(Name.MAIN_CLASS -> settings.mainClass.value)
    )
    val writer = new Jar(jfile).jarWriter(jarMainAttrs: _*)

    def writeClass(label: String, jclassName: String, jclassBytes: Array[Byte], sym: Symbol) {
      val path = jclassName + ".class"
      val out  = writer.newOutputStream(path)

      try out.write(jclassBytes, 0, jclassBytes.length)
      finally out.flush()

      informProgress("added " + label + path + " to jar")
    }
    override def close() = writer.close()
  }

  /** To be mixed-in with the BytecodeWriter that generates
   *  the class file to be disassembled.
   */
  trait JavapBytecodeWriter extends BytecodeWriter {
    val baseDir = Directory(settings.Ygenjavap.value).createDirectory()
    val cl      = ScalaClassLoader.appLoader

    def emitJavap(classFile: AbstractFile, javapFile: File) {
      val pw = javapFile.printWriter()
      try {
        val javap = new JavapClass(cl, pw) {
          override def findBytes(path: String): Array[Byte] = classFile.toByteArray
        }
        javap(Seq("-verbose", "-protected", classFile.name)) foreach (_.show())
      } finally pw.close()
    }
    abstract override def writeClass(label: String, jclassName: String, jclassBytes: Array[Byte], sym: Symbol) {
      super.writeClass(label, jclassName, jclassBytes, sym)

      val classFile = getFile(sym, jclassName, ".class")
      val segments  = jclassName.split("[./]")
      val javapFile = segments.foldLeft(baseDir: Path)(_ / _) changeExtension "javap" toFile;
      javapFile.parent.createDirectory()

      if (Javap.isAvailable(cl)) emitJavap(classFile, javapFile)
      else warning("No javap on classpath, skipping javap output.")
    }
  }

  trait ClassBytecodeWriter extends BytecodeWriter {
    val loader = new ClassBytesLoader(new java.net.URLClassLoader(Array(outputDirectory(RootClass).toURL), ClassLoader.getSystemClassLoader))

    class ClassBytesLoader(parent: ClassLoader) extends ClassLoader(parent) {
      private val asmWriter = new java.io.PrintWriter(Console.err, true)
      private val classBytesMap = mutable.Map[String, Array[Byte]]()
      private val classFileMap  = mutable.Map[String, AbstractFile]()
      private def size = classBytesMap.size
      override def findClass(name: String): Class[_] =
        (classBytesMap get name).fold[Class[_]](super.findClass(name))(bytes => defineClass(name, bytes, 0, bytes.length))

      def add(name: String, outfile: AbstractFile, bytes: Array[Byte]) {
        classBytesMap(name) = bytes
        classFileMap(name) = outfile.absolute
      }
      private def loads(name: String) = {
        try   { Class.forName(name, false, this) ; true }
        catch { case ex: LinkageError => false }
      }
      def verifyAll(): Unit = {
        val (ok, fail) = classBytesMap.keys partition loads
        if (fail.isEmpty) {
          if (settings.verbose.value)
            asmWriter.println(s"[$size/$size classes passed asm verification]")
        }
        else {
          asmWriter.println(s"[${fail.size}/$size classes failed asm verification]")
          fail foreach { name =>
            asmWriter.println("[" + classFileMap(name) + "]")
            CheckClassAdapter.verify(new asm.ClassReader(classBytesMap(name)), this, false, asmWriter)
          }
        }
      }
    }
    override def verify() {
      loader.verifyAll()
    }

    def writeClass(label: String, jclassName: String, jclassBytes: Array[Byte], sym: Symbol) {
      val outfile   = getFile(sym, jclassName, ".class")
      loader.add(jclassName.replace('/', '.'), outfile, jclassBytes)
      val outstream = new DataOutputStream(outfile.bufferedOutput)

      try outstream.write(jclassBytes, 0, jclassBytes.length)
      finally outstream.close()
      informProgress("wrote '" + label + "' to " + outfile)
    }
  }

  trait DumpBytecodeWriter extends BytecodeWriter {
    val baseDir = Directory(settings.Ydumpclasses.value).createDirectory()

    abstract override def writeClass(label: String, jclassName: String, jclassBytes: Array[Byte], sym: Symbol) {
      super.writeClass(label, jclassName, jclassBytes, sym)

      val pathName = jclassName
      val dumpFile = pathName.split("[./]").foldLeft(baseDir: Path) (_ / _) changeExtension "class" toFile;
      dumpFile.parent.createDirectory()
      val outstream = new DataOutputStream(new FileOutputStream(dumpFile.path))

      try outstream.write(jclassBytes, 0, jclassBytes.length)
      finally outstream.close()
    }
  }
}

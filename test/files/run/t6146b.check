t6146b.scala:15: warning: match may not be exhaustive.
It would fail on the following inputs: S2(), S3()
  def foo(f: F[Int]) = f match { case X.S1 => }
                       ^

scala> :power
Power mode enabled. :phase is at typer.
import scala.tools.nsc._, intp.global._, definitions._
Try :help or completions for vals._ and power._

scala> val u = rootMirror.universe; import u._, language._
u: $r.intp.global.type = <global>
import u._
import language._

scala> val S1 = typeOf[c.X.S1.type forSome { val c: C[_] }].typeSymbol.tpeHK
<console>:43: error: private value read escapes its defining scope as part of type u.Type
       val S1 = typeOf[c.X.S1.type forSome { val c: C[_] }].typeSymbol.tpeHK
           ^

scala> val S2 = typeOf[O.S2].typeSymbol.tpeHK
<console>:43: error: private value read escapes its defining scope as part of type u.Type
       val S2 = typeOf[O.S2].typeSymbol.tpeHK
           ^

scala> val S3 = typeOf[O.S3].typeSymbol.tpeHK
<console>:43: error: private value read escapes its defining scope as part of type u.Type
       val S3 = typeOf[O.S3].typeSymbol.tpeHK
           ^

scala> val S4 = typeOf[S4].typeSymbol.tpeHK
<console>:43: error: private value read escapes its defining scope as part of type u.Type
       val S4 = typeOf[S4].typeSymbol.tpeHK
           ^

scala> val F = typeOf[c.F[_] forSome { val c: C[_] }].typeSymbol.tpeHK
<console>:43: error: private value read escapes its defining scope as part of type u.Type
       val F = typeOf[c.F[_] forSome { val c: C[_] }].typeSymbol.tpeHK
           ^

scala> val fTpe = typeOf[O.type].decl(newTermName("foo")).paramss.head.head.tpe
<console>:43: error: private value read escapes its defining scope as part of type u.Type
       val fTpe = typeOf[O.type].decl(newTermName("foo")).paramss.head.head.tpe
           ^

scala> def memType(sub: Type, scrut: Type): Type =
  nestedMemberType(sub.typeSymbol, scrut.prefix, scrut.typeSymbol.owner)
<console>:43: error: private value read escapes its defining scope as part of type u.Type
       def memType(sub: Type, scrut: Type): Type =
                                            ^

scala> 

scala> val mt1 = memType(S1, fTpe)
<console>:43: error: not found: value memType
       val mt1 = memType(S1, fTpe)
                 ^
<console>:43: error: not found: value S1
       val mt1 = memType(S1, fTpe)
                         ^
<console>:43: error: not found: value fTpe
       val mt1 = memType(S1, fTpe)
                             ^

scala> global.typeDeconstruct.show(mt1)
<console>:44: error: not found: value mt1
       global.typeDeconstruct.show(mt1)
                                   ^

scala> memType(S2, fTpe)
<console>:44: error: not found: value memType
       memType(S2, fTpe)
       ^
<console>:44: error: not found: value S2
       memType(S2, fTpe)
               ^
<console>:44: error: not found: value fTpe
       memType(S2, fTpe)
                   ^

scala> memType(S3, fTpe)
<console>:44: error: not found: value memType
       memType(S3, fTpe)
       ^
<console>:44: error: not found: value S3
       memType(S3, fTpe)
               ^
<console>:44: error: not found: value fTpe
       memType(S3, fTpe)
                   ^

scala> memType(S4, fTpe)
<console>:44: error: not found: value memType
       memType(S4, fTpe)
       ^
<console>:44: error: not found: value fTpe
       memType(S4, fTpe)
                   ^

scala> :quit
